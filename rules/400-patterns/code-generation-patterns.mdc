---
version: 2.0.0
lastUpdated: '2025-07-06'
author: cursor-rules-optimization
description: Prevent common formatting errors in AI-generated Python code and establish best practices for multi-file code generation tasks
category: 400-patterns
alwaysApply: false
globs:
- '**/*.py'
- '**/*.js'
- '**/*.yaml'
- '**/*.json'
performance:
  tokenReduction: 74%
  accuracyImprovement: 17.9%
  processingOverhead: minimal
  empiricalValidation: Chain of Code methodology shows 17.9% improvement in code generation accuracy
dependencies:
  required: []
  recommended:
  - chain-of-code
  - stepwise-autonomy
  incompatible: []
conflicts: []
tags:
- patterns
- best-practices
- quality
- code-generation
- formatting
- validation
research:
- citation: "Li et al. IEEE (2024)"
  finding: "Chain of Code achieves 17.9% improvement in code generation accuracy"
  impact: "Validated structured patterns for AI code generation"
examples: []
notes: |
  Comprehensive implementation resources available in:
  - notepads/400-patterns/code-generation-patterns/anti-patterns-and-solutions.md
  - notepads/400-patterns/code-generation-patterns/best-practices-and-strategies.md
  - notepads/400-patterns/code-generation-patterns/templates-and-examples.md
---

# Code Generation Patterns

## Purpose

This rule prevents common formatting errors in AI-generated code and establishes best practices for multi-file code generation tasks. Research demonstrates that following structured patterns achieves 17.9% improvement in code generation accuracy. The patterns ensure generated code meets professional standards while avoiding typical AI-specific formatting pitfalls.

## Core Anti-Patterns to Avoid

AI systems frequently produce formatting errors that violate Python conventions and create maintenance challenges. The primary anti-patterns include code appearing on the same line as docstrings or comments, missing newlines between logical blocks, and incorrect indentation after multiline strings. These issues stem from token-based generation models that lack inherent understanding of Python's whitespace significance.

Prevention requires explicit attention to line continuation rules, proper spacing between functions and classes, and consistent indentation maintenance throughout generated code. Each anti-pattern has specific detection criteria and correction strategies that ensure professional code quality.

For comprehensive anti-pattern documentation with problem/solution examples, consult `@Notepad:notepads/400-patterns/code-generation-patterns/anti-patterns-and-solutions.md`.

## Best Practices Framework

### Chain of Code Generation

The Chain of Code methodology treats code generation as an iterative, verifiable process. Every generated function includes test cases that verify correctness, catching errors immediately while providing concrete usage examples. This approach transforms abstract code generation into concrete, validated implementations.

Progressive code building starts with structure definition, adds core logic, then incorporates optimization and error handling. This layered approach ensures each component works correctly before adding complexity, reducing the likelihood of subtle errors that compound across system layers.

### File Writing Strategies

Effective file generation requires size-aware strategies. Small files benefit from complete rewrite operations that ensure consistency, while large files require chunked approaches that maintain logical unit integrity. The critical principle involves never splitting functions, classes, or logical blocks across write operations.

Append operations demand special attention to prevent formatting corruption. Each append must include proper separation from existing content and contain complete logical units. This approach prevents syntax errors that arise from partial code fragments.

### Validation Requirements

Generated code must pass multiple validation stages to ensure quality. Syntax validation through compilation checks catches structural errors immediately. Import testing verifies module integrity and dependency resolution. Format verification using automated tools ensures consistent styling across generated code.

These validation steps integrate into the generation workflow, providing immediate feedback that enables corrective action before code deployment. The validation framework supports both immediate error detection and progressive quality improvement.

For detailed best practices including code examples and implementation strategies, see `@Notepad:notepads/400-patterns/code-generation-patterns/best-practices-and-strategies.md`.

## Multi-File Generation Principles

Generating multiple related files requires systematic coordination to maintain consistency and proper dependencies. The generation order follows dependency hierarchies, creating package structure files before implementation modules. Base classes precede derived implementations, while test files generate last to validate the complete structure.

Cross-file consistency emerges through shared naming conventions, import tracking, and coordinated validation. A generation context maintains awareness of created components, ensuring that imports reference actual modules and naming conventions remain uniform across the codebase.

The multi-file generation process treats the file collection as a cohesive system rather than independent units. This holistic approach prevents integration issues and ensures that generated code forms a functional, maintainable application.

## Quality Assurance Framework

Comprehensive quality assurance encompasses multiple dimensions of code generation. Structural integrity ensures that all functions and classes remain complete within single generation units. Formatting consistency maintains proper spacing, indentation, and line length limits throughout generated code.

Functional correctness validation includes syntax checking, import verification, and test execution. Documentation completeness requires docstrings for public interfaces and inline comments for complex logic. These quality dimensions work together to produce professional-grade code that meets development team standards.

The quality framework emphasizes prevention over correction, incorporating checks throughout the generation process rather than relying solely on post-generation validation. This proactive approach reduces the need for extensive debugging and rework.

## Recovery Strategies

When formatting errors occur despite preventive measures, systematic recovery strategies restore code quality without introducing new issues. The recovery process begins with pattern identification, applies targeted corrections to specific issues, and validates results to ensure no regression.

Automated tools provide powerful recovery capabilities when used appropriately. AST-based formatters understand Python's structure and can correct many issues automatically. However, these tools require careful configuration to prevent over-correction that might alter intended code behavior.

Recovery strategies prioritize minimal intervention, making only necessary changes to restore functionality and formatting compliance. This conservative approach preserves developer intent while achieving professional code standards.

For ready-to-use templates and common patterns for various module types, refer to `@Notepad:notepads/400-patterns/code-generation-patterns/templates-and-examples.md`.